package order

import (
	"context"
	"encoding/hex"
	"fmt"
	"strings"

	"github.com/NethermindEth/starknet.go/utils"
	"github.com/google/uuid"
	"github.com/paycrest/aggregator/ent"
	"github.com/paycrest/aggregator/ent/fiatcurrency"
	"github.com/paycrest/aggregator/ent/lockorderfulfillment"
	"github.com/paycrest/aggregator/ent/lockpaymentorder"
	networkent "github.com/paycrest/aggregator/ent/network"
	"github.com/paycrest/aggregator/ent/paymentorder"
	"github.com/paycrest/aggregator/ent/providerordertoken"
	"github.com/paycrest/aggregator/ent/providerprofile"
	tokenent "github.com/paycrest/aggregator/ent/token"
	"github.com/paycrest/aggregator/services/starknet"
	db "github.com/paycrest/aggregator/storage"
	"github.com/paycrest/aggregator/types"
	u "github.com/paycrest/aggregator/utils"
	cryptoUtils "github.com/paycrest/aggregator/utils/crypto"
	"github.com/shopspring/decimal"
)

// OrderStarknet provides functionality related to on-chain interactions for payment orders on Starknet
type OrderStarknet struct {
	client *starknet.Client
}

// NewOrderStarknet creates a new instance of OrderStarknet
func NewOrderStarknet(ctx context.Context) (types.OrderService, error) {
	client, err := starknet.NewClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("NewOrderStarknet: %w", err)
	}
	return OrderStarknet{
		client: client,
	}, nil
}

// CreateOrder creates a new payment order on-chain for Starknet
func (s OrderStarknet) CreateOrder(ctx context.Context, orderID uuid.UUID) error {
	var err error
	orderIDPrefix := strings.Split(orderID.String(), "-")[0]

	order, err := db.Client.PaymentOrder.
		Query().
		Where(paymentorder.IDEQ(orderID)).
		WithToken(func(tq *ent.TokenQuery) {
			tq.WithNetwork()
		}).
		WithSenderProfile().
		WithRecipient().
		WithReceiveAddress().
		WithLinkedAddress().
		Only(ctx)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.fetchOrder: %w", orderIDPrefix, err)
	}

	if order.MessageHash != "" {
		return nil
	}

	// Create createOrder data
	encryptedOrderRecipient, err := cryptoUtils.EncryptOrderRecipient(order.Edges.Recipient)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.encryptOrderRecipient: %w", orderIDPrefix, err)
	}

	// Save the encrypted order recipient to the message hash field
	_, err = order.Update().
		SetMessageHash(encryptedOrderRecipient).
		SetStatus(paymentorder.StatusPending).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.updateMessageHash: %w", orderIDPrefix, err)
	}

	_, err = order.Update().
		SetStatus(paymentorder.StatusInitiated).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.updateStatus: %w", orderIDPrefix, err)
	}

	// We need to get the salt from the receive address table to generate the account
	salt := order.Edges.ReceiveAddress.Salt
	if salt == nil && order.Edges.LinkedAddress != nil {
		salt = order.Edges.LinkedAddress.Salt
	}
	// derive seed from salt. salt is generated by adding suffix of "-paycrest" to seed
	seed := strings.TrimSuffix(string(salt), "-paycrest")

	starknetDeterministicAccount, err := s.client.GenerateDeterministicAccount(seed)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.generateDeterministicAccount: %w", orderIDPrefix, err)
	}

	gatewayContractAddressFelt, _ := utils.HexToFelt(order.Edges.Token.Edges.Network.GatewayContractAddress)
	tokenContractFelt, _ := utils.HexToFelt(order.Edges.Token.ContractAddress)
	orderAmountFelt, _ := utils.HexToFelt(u.ToSubunit(order.Amount, order.Edges.Token.Decimals).String())
	rateFelt, _ := utils.HexToFelt(order.Rate.Mul(decimal.NewFromInt(100)).BigInt().String())
	senderFeeRecipientFelt, _ := utils.HexToFelt(order.FeeAddress)
	senderFeeFelt, _ := utils.HexToFelt(u.ToSubunit(order.SenderFee, order.Edges.Token.Decimals).String())
	refundAddressFelt, _ := utils.HexToFelt(order.ReturnAddress)

	buildReq, buildResp, err := s.client.BuildApprovalAndCreateOrderCall(
		ctx,
		starknetDeterministicAccount,
		gatewayContractAddressFelt,
		tokenContractFelt,
		orderAmountFelt,
		rateFelt,
		senderFeeRecipientFelt,
		senderFeeFelt,
		refundAddressFelt,
		encryptedOrderRecipient,
	)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.buildCreateOrderCall: %w", orderIDPrefix, err)
	}

	execReq, err := s.client.GetExecutableRequest(
		ctx,
		starknetDeterministicAccount,
		*buildReq,
		buildResp,
	)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.getExecutableRequest: %w", orderIDPrefix, err)
	}

	_, err = s.client.PaymasterExecuteTransaction(ctx, execReq)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.paymasterExecuteTransaction: %w", orderIDPrefix, err)
	}

	return nil
}

// RefundOrder processes order refund on Starknet
func (s OrderStarknet) RefundOrder(ctx context.Context, network *ent.Network, orderID string) error {
	orderIDPrefix := strings.Split(orderID, "-")[0]

	lockOrder, err := db.Client.LockPaymentOrder.
		Query().
		Where(
			lockpaymentorder.GatewayIDEQ(orderID),
			lockpaymentorder.HasTokenWith(
				tokenent.HasNetworkWith(
					networkent.IdentifierEQ(network.Identifier),
				),
			),
		).
		WithToken(func(tq *ent.TokenQuery) {
			tq.WithNetwork()
		}).
		First(ctx)
	if err != nil {
		return fmt.Errorf("%s - RefundOrder.fetchLockOrder: %w", orderIDPrefix, err)
	}

	feeFelt, err := utils.HexToFelt(u.ToSubunit(decimal.NewFromInt(0), lockOrder.Edges.Token.Decimals).String())
	if err != nil {
		return fmt.Errorf("%s - RefundOrder.parseFee: %w", orderIDPrefix, err)
	}

	gatewayContractAddressFelt, _ := utils.HexToFelt(lockOrder.Edges.Token.Edges.Network.GatewayContractAddress)
	gatewayOrderIDFelt, _ := utils.HexToFelt(lockOrder.GatewayID)

	// derive seed from salt. salt is generated by adding suffix of "-paycrest" to seed
	seed := strings.TrimSuffix(s.client.AggregatorSalt, "-paycrest")

	aggregatorDeterministicAccount, err := s.client.GenerateDeterministicAccount(seed)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.generateDeterministicAccount: %w", orderIDPrefix, err)
	}

	// Build refund transaction
	buildReq, buildResp, err := s.client.BuildRefundOrderCall(
		ctx,
		aggregatorDeterministicAccount.NewAccount.Address,
		gatewayContractAddressFelt,
		gatewayOrderIDFelt,
		feeFelt,
	)
	if err != nil {
		return fmt.Errorf("%s - RefundOrder.buildRefundCall: %w", orderIDPrefix, err)
	}

	execReq, err := s.client.GetExecutableRequest(
		ctx,
		aggregatorDeterministicAccount,
		*buildReq,
		buildResp,
	)
	if err != nil {
		return fmt.Errorf("%s - RefundOrder.getExecutableRequest: %w", orderIDPrefix, err)
	}

	// Execute the refund transaction through paymaster
	_, err = s.client.PaymasterExecuteTransaction(ctx, execReq)
	if err != nil {
		return fmt.Errorf("%s - RefundOrder.paymasterExecuteTransaction: %w", orderIDPrefix, err)
	}

	return nil
}

// SettleOrder settles a completed order on Starknet
func (s OrderStarknet) SettleOrder(ctx context.Context, orderID uuid.UUID) error {
	var err error

	orderIDPrefix := strings.Split(orderID.String(), "-")[0]

	// Fetch payment order from db
	order, err := db.Client.LockPaymentOrder.
		Query().
		Where(
			lockpaymentorder.IDEQ(orderID),
			lockpaymentorder.StatusEQ(lockpaymentorder.StatusValidated),
			lockpaymentorder.HasFulfillmentsWith(
				lockorderfulfillment.ValidationStatusEQ(lockorderfulfillment.ValidationStatusSuccess),
			),
		).
		WithToken(func(tq *ent.TokenQuery) {
			tq.WithNetwork()
		}).
		WithProvider().
		Only(ctx)
	if err != nil {
		return fmt.Errorf("%s - SettleOrder.fetchOrder: %w", orderIDPrefix, err)
	}

	institution, err := u.GetInstitutionByCode(ctx, order.Institution, true)
	if err != nil {
		return fmt.Errorf("failed to get institution: %w", err)
	}

	// Fetch provider address from db
	token, err := db.Client.ProviderOrderToken.
		Query().
		Where(
			providerordertoken.NetworkEQ(order.Edges.Token.Edges.Network.Identifier),
			providerordertoken.HasProviderWith(
				providerprofile.IDEQ(order.Edges.Provider.ID),
			),
			providerordertoken.HasTokenWith(
				tokenent.IDEQ(order.Edges.Token.ID),
			),
			providerordertoken.HasCurrencyWith(
				fiatcurrency.CodeEQ(institution.Edges.FiatCurrency.Code),
			),
			providerordertoken.AddressNEQ(""),
		).
		Only(ctx)
	if err != nil {
		return fmt.Errorf("failed to fetch provider order token: %w", err)
	}

	orderPercent, _ := order.OrderPercent.
		Mul(decimal.NewFromInt(1000)). // convert percent to BPS
		Float64()

	decodedOrderID, err := hex.DecodeString(order.GatewayID[2:])
	if err != nil {
		return fmt.Errorf("failed to decode orderID: %w", err)
	}

	splitOrderID := strings.ReplaceAll(order.ID.String(), "-", "")

	// derive seed from salt. salt is generated by adding suffix of "-paycrest" to seed
	seed := strings.TrimSuffix(s.client.AggregatorSalt, "-paycrest")

	aggregatorDeterministicAccount, err := s.client.GenerateDeterministicAccount(seed)
	if err != nil {
		return fmt.Errorf("%s - CreateOrder.generateDeterministicAccount: %w", orderIDPrefix, err)
	}

	gatewayContractAddressFelt, _ := utils.HexToFelt(order.Edges.Token.Edges.Network.GatewayContractAddress)
	gatewayOrderIDFelt, _ := utils.HexToFelt(string(decodedOrderID))
	splitOrderIDFelt, _ := utils.HexToFelt(splitOrderID)
	providerContractAddressFelt, _ := utils.HexToFelt(token.Address)

	buildReq, buildResp, err := s.client.BuildSettleOrderCall(
		ctx,
		aggregatorDeterministicAccount.NewAccount.Address,
		gatewayContractAddressFelt,
		splitOrderIDFelt,
		gatewayOrderIDFelt,
		providerContractAddressFelt,
		uint64(orderPercent),
		0, // rebate percent
	)
	if err != nil {
		return fmt.Errorf("%s - SettleOrder.buildSettleCall: %w", orderIDPrefix, err)
	}

	execReq, err := s.client.GetExecutableRequest(
		ctx,
		aggregatorDeterministicAccount,
		*buildReq,
		buildResp,
	)
	if err != nil {
		return fmt.Errorf("%s - SettleOrder.getExecutableRequest: %w", orderIDPrefix, err)
	}

	// Execute the settlement transaction through paymaster
	_, err = s.client.PaymasterExecuteTransaction(ctx, execReq)
	if err != nil {
		return fmt.Errorf("%s - SettleOrder.paymasterExecuteTransaction: %w", orderIDPrefix, err)
	}

	return nil
}
